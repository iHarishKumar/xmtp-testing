import { join } from 'node:path';
import process from 'node:process';
import { GroupUpdatedCodec, ContentTypeGroupUpdated } from '@xmtp/content-type-group-updated';
import { ContentTypeText, TextCodec } from '@xmtp/content-type-text';
import { getInboxIdForIdentifier as getInboxIdForIdentifier$1, generateInboxId as generateInboxId$1, createClient, verifySignedWithPublicKey, isAddressAuthorized, isInstallationAuthorized } from '@xmtp/node-bindings';
export { ConsentEntityType, ConsentState, ConversationType, DeliveryStatus, GroupMember, GroupMembershipState, GroupMessageKind, GroupMetadata, GroupPermissions, GroupPermissionsOptions, IdentifierKind, LogLevel, MetadataField, PermissionLevel, PermissionPolicy, PermissionUpdateType, SignatureRequestType, SortDirection } from '@xmtp/node-bindings';
import { ContentTypeId } from '@xmtp/content-type-primitives';
import bindingsVersion from '@xmtp/node-bindings/version.json' with { type: 'json' };

class AsyncStream {
    #done = false;
    #resolveNext;
    #queue;
    onReturn = undefined;
    constructor() {
        this.#queue = [];
        this.#resolveNext = null;
        this.#done = false;
    }
    get isDone() {
        return this.#done;
    }
    callback = (error, value) => {
        if (error) {
            throw error;
        }
        if (this.#done) {
            return;
        }
        if (this.#resolveNext) {
            this.#resolveNext({
                done: false,
                value,
            });
            this.#resolveNext = null;
        }
        else {
            this.#queue.push(value);
        }
    };
    next = () => {
        if (this.#queue.length > 0) {
            return Promise.resolve({
                done: false,
                value: this.#queue.shift(),
            });
        }
        else if (this.#done) {
            return Promise.resolve({
                done: true,
                value: undefined,
            });
        }
        else {
            return new Promise((resolve) => {
                this.#resolveNext = resolve;
            });
        }
    };
    return = (value) => {
        this.#done = true;
        this.onReturn?.();
        return Promise.resolve({
            done: true,
            value,
        });
    };
    [Symbol.asyncIterator]() {
        return this;
    }
}

function nsToDate(ns) {
    return new Date(ns / 1_000_000);
}

class DecodedMessage {
    #client;
    content;
    contentType;
    conversationId;
    deliveryStatus;
    fallback;
    compression;
    id;
    kind;
    parameters;
    senderInboxId;
    sentAt;
    sentAtNs;
    constructor(client, message) {
        this.#client = client;
        this.id = message.id;
        this.sentAtNs = message.sentAtNs;
        this.sentAt = nsToDate(message.sentAtNs);
        this.conversationId = message.convoId;
        this.senderInboxId = message.senderInboxId;
        switch (message.kind) {
            case 0 /* GroupMessageKind.Application */:
                this.kind = "application";
                break;
            case 1 /* GroupMessageKind.MembershipChange */:
                this.kind = "membership_change";
                break;
            // no default
        }
        switch (message.deliveryStatus) {
            case 0 /* DeliveryStatus.Unpublished */:
                this.deliveryStatus = "unpublished";
                break;
            case 1 /* DeliveryStatus.Published */:
                this.deliveryStatus = "published";
                break;
            case 2 /* DeliveryStatus.Failed */:
                this.deliveryStatus = "failed";
                break;
            // no default
        }
        this.contentType = message.content.type
            ? new ContentTypeId(message.content.type)
            : undefined;
        this.parameters = message.content.parameters;
        this.fallback = message.content.fallback;
        this.compression = message.content.compression;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.content = this.contentType
            ? this.#client.decodeContent(message, this.contentType)
            : undefined;
    }
}

class Conversation {
    #client;
    #conversation;
    #lastMessage;
    constructor(client, conversation, lastMessage) {
        this.#client = client;
        this.#conversation = conversation;
        this.#lastMessage = lastMessage
            ? new DecodedMessage(client, lastMessage)
            : undefined;
    }
    get id() {
        return this.#conversation.id();
    }
    get isActive() {
        return this.#conversation.isActive();
    }
    get addedByInboxId() {
        return this.#conversation.addedByInboxId();
    }
    get createdAtNs() {
        return this.#conversation.createdAtNs();
    }
    get createdAt() {
        return nsToDate(this.createdAtNs);
    }
    async metadata() {
        const metadata = await this.#conversation.groupMetadata();
        return {
            creatorInboxId: metadata.creatorInboxId(),
            conversationType: metadata.conversationType(),
        };
    }
    async members() {
        return this.#conversation.listMembers();
    }
    async sync() {
        return this.#conversation.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversation.stream((error, value) => {
            const message = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(error, message);
            callback?.(error, message);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async publishMessages() {
        return this.#conversation.publishMessages();
    }
    sendOptimistic(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#conversation.sendOptimistic(encodedContent);
    }
    async send(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? ContentTypeText)
            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.#client.encodeContent(content, contentType);
        return this.#conversation.send(encodedContent);
    }
    async messages(options) {
        const messages = await this.#conversation.findMessages(options);
        return (messages
            .map((message) => new DecodedMessage(this.#client, message))
            // filter out messages without content
            .filter((message) => message.content !== undefined));
    }
    async lastMessage() {
        return this.#lastMessage ?? (await this.messages({ limit: 1 }))[0];
    }
    get consentState() {
        return this.#conversation.consentState();
    }
    updateConsentState(consentState) {
        this.#conversation.updateConsentState(consentState);
    }
    messageDisappearingSettings() {
        return this.#conversation.messageDisappearingSettings() ?? undefined;
    }
    async updateMessageDisappearingSettings(fromNs, inNs) {
        return this.#conversation.updateMessageDisappearingSettings({
            fromNs,
            inNs,
        });
    }
    async removeMessageDisappearingSettings() {
        return this.#conversation.removeMessageDisappearingSettings();
    }
    isMessageDisappearingEnabled() {
        return this.#conversation.isMessageDisappearingEnabled();
    }
    pausedForVersion() {
        return this.#conversation.pausedForVersion() ?? undefined;
    }
}

class Dm extends Conversation {
    #conversation;
    constructor(client, conversation, lastMessage) {
        super(client, conversation, lastMessage);
        this.#conversation = conversation;
    }
    get peerInboxId() {
        return this.#conversation.dmPeerInboxId();
    }
}

class Group extends Conversation {
    #conversation;
    constructor(client, conversation, lastMessage) {
        super(client, conversation, lastMessage);
        this.#conversation = conversation;
    }
    get name() {
        return this.#conversation.groupName();
    }
    async updateName(name) {
        return this.#conversation.updateGroupName(name);
    }
    get imageUrl() {
        return this.#conversation.groupImageUrlSquare();
    }
    async updateImageUrl(imageUrl) {
        return this.#conversation.updateGroupImageUrlSquare(imageUrl);
    }
    get description() {
        return this.#conversation.groupDescription();
    }
    async updateDescription(description) {
        return this.#conversation.updateGroupDescription(description);
    }
    get permissions() {
        const permissions = this.#conversation.groupPermissions();
        return {
            policyType: permissions.policyType(),
            policySet: permissions.policySet(),
        };
    }
    async updatePermission(permissionType, policy, metadataField) {
        return this.#conversation.updatePermissionPolicy(permissionType, policy, metadataField);
    }
    get admins() {
        return this.#conversation.adminList();
    }
    get superAdmins() {
        return this.#conversation.superAdminList();
    }
    isAdmin(inboxId) {
        return this.#conversation.isAdmin(inboxId);
    }
    isSuperAdmin(inboxId) {
        return this.#conversation.isSuperAdmin(inboxId);
    }
    async addMembersByIdentifiers(identifiers) {
        return this.#conversation.addMembers(identifiers);
    }
    async addMembers(inboxIds) {
        return this.#conversation.addMembersByInboxId(inboxIds);
    }
    async removeMembersByIdentifiers(identifiers) {
        return this.#conversation.removeMembers(identifiers);
    }
    async removeMembers(inboxIds) {
        return this.#conversation.removeMembersByInboxId(inboxIds);
    }
    async addAdmin(inboxId) {
        return this.#conversation.addAdmin(inboxId);
    }
    async removeAdmin(inboxId) {
        return this.#conversation.removeAdmin(inboxId);
    }
    async addSuperAdmin(inboxId) {
        return this.#conversation.addSuperAdmin(inboxId);
    }
    async removeSuperAdmin(inboxId) {
        return this.#conversation.removeSuperAdmin(inboxId);
    }
}

class Conversations {
    #client;
    #conversations;
    constructor(client, conversations) {
        this.#client = client;
        this.#conversations = conversations;
    }
    async getConversationById(id) {
        try {
            // findGroupById will throw if group is not found
            const group = this.#conversations.findGroupById(id);
            const metadata = await group.groupMetadata();
            return metadata.conversationType() === "group"
                ? new Group(this.#client, group)
                : new Dm(this.#client, group);
        }
        catch {
            return undefined;
        }
    }
    getDmByInboxId(inboxId) {
        try {
            // findDmByTargetInboxId will throw if group is not found
            const group = this.#conversations.findDmByTargetInboxId(inboxId);
            return new Dm(this.#client, group);
        }
        catch {
            return undefined;
        }
    }
    getMessageById(id) {
        try {
            // findMessageById will throw if message is not found
            const message = this.#conversations.findMessageById(id);
            return new DecodedMessage(this.#client, message);
        }
        catch {
            return undefined;
        }
    }
    async newGroupWithIdentifiers(identifiers, options) {
        const group = await this.#conversations.createGroup(identifiers, options);
        const conversation = new Group(this.#client, group);
        return conversation;
    }
    async newGroup(inboxIds, options) {
        const group = await this.#conversations.createGroupByInboxId(inboxIds, options);
        const conversation = new Group(this.#client, group);
        return conversation;
    }
    async newDmWithIdentifier(identifier, options) {
        const group = await this.#conversations.createDm(identifier, options);
        const conversation = new Dm(this.#client, group);
        return conversation;
    }
    async newDm(inboxId, options) {
        const group = await this.#conversations.createDmByInboxId(inboxId, options);
        const conversation = new Dm(this.#client, group);
        return conversation;
    }
    async list(options) {
        const groups = this.#conversations.list(options);
        return Promise.all(groups.map(async (item) => {
            const metadata = await item.conversation.groupMetadata();
            return metadata.conversationType() === "dm"
                ? new Dm(this.#client, item.conversation, item.lastMessage)
                : new Group(this.#client, item.conversation, item.lastMessage);
        }));
    }
    listGroups(options) {
        const groups = this.#conversations.listGroups(options);
        return groups.map((item) => {
            const conversation = new Group(this.#client, item.conversation, item.lastMessage);
            return conversation;
        });
    }
    listDms(options) {
        const groups = this.#conversations.listDms(options);
        return groups.map((item) => {
            const conversation = new Dm(this.#client, item.conversation, item.lastMessage);
            return conversation;
        });
    }
    async sync() {
        return this.#conversations.sync();
    }
    async syncAll(consentStates) {
        return this.#conversations.syncAllConversations(consentStates);
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.stream((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            value
                ?.groupMetadata()
                .then((metadata) => {
                const conversation = metadata.conversationType() === "dm"
                    ? new Dm(this.#client, value)
                    : new Group(this.#client, value);
                asyncStream.callback(null, conversation);
                callback?.(null, conversation);
            })
                .catch((error) => {
                asyncStream.callback(error, undefined);
                callback?.(error, undefined);
            });
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    streamGroups(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamGroups((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            const conversation = value ? new Group(this.#client, value) : undefined;
            asyncStream.callback(null, conversation);
            callback?.(null, conversation);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    streamDms(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamDms((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            const conversation = value ? new Dm(this.#client, value) : undefined;
            asyncStream.callback(null, conversation);
            callback?.(null, conversation);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllMessages((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(null, decodedMessage);
            callback?.(null, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllGroupMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllGroupMessages((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(null, decodedMessage);
            callback?.(null, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllDmMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllDmMessages((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            const decodedMessage = value
                ? new DecodedMessage(this.#client, value)
                : undefined;
            asyncStream.callback(null, decodedMessage);
            callback?.(null, decodedMessage);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    hmacKeys() {
        return this.#conversations.getHmacKeys();
    }
}

const version = `${bindingsVersion.branch}@${bindingsVersion.version} (${bindingsVersion.date})`;

class Preferences {
    #client;
    #conversations;
    constructor(client, conversations) {
        this.#client = client;
        this.#conversations = conversations;
    }
    async inboxState(refreshFromNetwork = false) {
        return this.#client.inboxState(refreshFromNetwork);
    }
    async getLatestInboxState(inboxId) {
        return this.#client.getLatestInboxState(inboxId);
    }
    async inboxStateFromInboxIds(inboxIds, refreshFromNetwork) {
        return this.#client.addressesFromInboxId(refreshFromNetwork ?? false, inboxIds);
    }
    async setConsentStates(consentStates) {
        return this.#client.setConsentStates(consentStates);
    }
    async getConsentState(entityType, entity) {
        return this.#client.getConsentState(entityType, entity);
    }
    streamConsent(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamConsent((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            asyncStream.callback(null, value);
            callback?.(null, value);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
    streamPreferences(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamPreferences((err, value) => {
            if (err) {
                asyncStream.callback(err, undefined);
                callback?.(err, undefined);
                return;
            }
            // TODO: remove this once the node bindings type is updated
            asyncStream.callback(null, value);
            callback?.(null, value);
        });
        asyncStream.onReturn = stream.end.bind(stream);
        return asyncStream;
    }
}

const ApiUrls = {
    local: "http://localhost:5556",
    dev: "https://grpc.dev.xmtp.network:443",
    production: "https://grpc.production.xmtp.network:443",
};
const HistorySyncUrls = {
    local: "http://localhost:5558",
    dev: "https://message-history.dev.ephemera.network",
    production: "https://message-history.production.ephemera.network",
};
class Client {
    #innerClient;
    #conversations;
    #preferences;
    #signer;
    #codecs;
    constructor(client, signer, codecs) {
        this.#innerClient = client;
        const conversations = client.conversations();
        this.#conversations = new Conversations(this, conversations);
        this.#preferences = new Preferences(client, conversations);
        this.#signer = signer;
        this.#codecs = new Map(codecs.map((codec) => [codec.contentType.toString(), codec]));
    }
    static async create(signer, encryptionKey, options) {
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        const isSecure = host.startsWith("https");
        const identifier = await signer.getIdentifier();
        const inboxId = (await getInboxIdForIdentifier$1(host, isSecure, identifier)) ||
            generateInboxId$1(identifier);
        const dbPath = options?.dbPath ||
            join(process.cwd(), `xmtp-${options?.env || "dev"}-${inboxId}.db3`);
        const logOptions = {
            structured: options?.structuredLogging ?? false,
            level: options?.loggingLevel ?? "off" /* LogLevel.off */,
        };
        const historySyncUrl = options?.historySyncUrl || HistorySyncUrls[options?.env || "dev"];
        const client = new Client(await createClient(host, isSecure, dbPath, inboxId, identifier, encryptionKey, historySyncUrl, logOptions), signer, [new GroupUpdatedCodec(), new TextCodec(), ...(options?.codecs ?? [])]);
        if (!options?.disableAutoRegister) {
            await client.register();
        }
        return client;
    }
    get identifier() {
        return this.#innerClient.accountIdentifier;
    }
    get inboxId() {
        return this.#innerClient.inboxId();
    }
    get installationId() {
        return this.#innerClient.installationId();
    }
    get installationIdBytes() {
        return this.#innerClient.installationIdBytes();
    }
    get isRegistered() {
        return this.#innerClient.isRegistered();
    }
    get conversations() {
        return this.#conversations;
    }
    get preferences() {
        return this.#preferences;
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register` function instead.
     */
    async unsafe_createInboxSignatureText() {
        try {
            const signatureText = await this.#innerClient.createInboxSignatureText();
            return signatureText;
        }
        catch {
            return undefined;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `unsafe_addAccount` function instead.
     *
     * The `allowInboxReassign` parameter must be true or this function will
     * throw an error.
     */
    async unsafe_addAccountSignatureText(newAccountIdentifier, allowInboxReassign = false) {
        if (!allowInboxReassign) {
            throw new Error("Unable to create add identifier signature text, `allowInboxReassign` must be true");
        }
        try {
            const signatureText = await this.#innerClient.addIdentifierSignatureText(newAccountIdentifier);
            return signatureText;
        }
        catch {
            return undefined;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `removeAccount` function instead.
     */
    async unsafe_removeAccountSignatureText(identifier) {
        try {
            const signatureText = await this.#innerClient.revokeIdentifierSignatureText(identifier);
            return signatureText;
        }
        catch {
            return undefined;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `revokeAllOtherInstallations` function
     * instead.
     */
    async unsafe_revokeAllOtherInstallationsSignatureText() {
        try {
            const signatureText = await this.#innerClient.revokeAllOtherInstallationsSignatureText();
            return signatureText;
        }
        catch {
            return undefined;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `revokeInstallations` function instead.
     */
    async unsafe_revokeInstallationsSignatureText(installationIds) {
        try {
            const signatureText = await this.#innerClient.revokeInstallationsSignatureText(installationIds);
            return signatureText;
        }
        catch {
            return undefined;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register`, `addAccount`,
     * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`
     * functions instead.
     */
    async unsafe_addSignature(signatureType, signatureText, signer) {
        switch (signer.type) {
            case "SCW":
                await this.#innerClient.addScwSignature(signatureType, await signer.signMessage(signatureText), signer.getChainId(), signer.getBlockNumber?.());
                break;
            case "EOA":
                await this.#innerClient.addEcdsaSignature(signatureType, await signer.signMessage(signatureText));
                break;
        }
    }
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register`, `addAccount`,
     * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`
     * functions instead.
     */
    async unsafe_applySignatures() {
        return this.#innerClient.applySignatureRequests();
    }
    async register() {
        const signatureText = await this.unsafe_createInboxSignatureText();
        // if the signature text is not available, the client is already registered
        if (!signatureText) {
            return;
        }
        await this.unsafe_addSignature(1 /* SignatureRequestType.CreateInbox */, signatureText, this.#signer);
        return this.#innerClient.registerIdentity();
    }
    /**
     * WARNING: This function should be used with caution. Adding a wallet already
     * associated with an inboxId will cause the wallet to lose access to
     * that inbox.
     *
     * The `allowInboxReassign` parameter must be true to reassign an inbox
     * already associated with a different account.
     */
    async unsafe_addAccount(newAccountSigner, allowInboxReassign = false) {
        // check for existing inbox id
        const identifier = await newAccountSigner.getIdentifier();
        const existingInboxId = await this.getInboxIdByIdentifier(identifier);
        if (existingInboxId && !allowInboxReassign) {
            throw new Error(`Signer address already associated with inbox ${existingInboxId}`);
        }
        const signatureText = await this.unsafe_addAccountSignatureText(identifier, true);
        if (!signatureText) {
            throw new Error("Unable to generate add account signature text");
        }
        await this.unsafe_addSignature(0 /* SignatureRequestType.AddWallet */, signatureText, newAccountSigner);
        await this.unsafe_applySignatures();
    }
    async removeAccount(identifier) {
        const signatureText = await this.unsafe_removeAccountSignatureText(identifier);
        if (!signatureText) {
            throw new Error("Unable to generate remove account signature text");
        }
        await this.unsafe_addSignature(2 /* SignatureRequestType.RevokeWallet */, signatureText, this.#signer);
        await this.unsafe_applySignatures();
    }
    async revokeAllOtherInstallations() {
        const signatureText = await this.unsafe_revokeAllOtherInstallationsSignatureText();
        if (!signatureText) {
            throw new Error("Unable to generate revoke all other installations signature text");
        }
        await this.unsafe_addSignature(3 /* SignatureRequestType.RevokeInstallations */, signatureText, this.#signer);
        await this.unsafe_applySignatures();
    }
    async revokeInstallations(installationIds) {
        const signatureText = await this.unsafe_revokeInstallationsSignatureText(installationIds);
        if (!signatureText) {
            throw new Error("Unable to generate revoke installations signature text");
        }
        await this.unsafe_addSignature(3 /* SignatureRequestType.RevokeInstallations */, signatureText, this.#signer);
        await this.unsafe_applySignatures();
    }
    async canMessage(identifiers) {
        const canMessage = await this.#innerClient.canMessage(identifiers);
        return new Map(Object.entries(canMessage));
    }
    static async canMessage(identifiers, env) {
        const accountAddress = "0x0000000000000000000000000000000000000000";
        const host = ApiUrls[env || "dev"];
        const isSecure = host.startsWith("https");
        const identifier = {
            identifierKind: 0 /* IdentifierKind.Ethereum */,
            identifier: accountAddress,
        };
        const inboxId = (await getInboxIdForIdentifier$1(host, isSecure, identifier)) ||
            generateInboxId$1(identifier);
        const signer = {
            type: "EOA",
            getIdentifier: () => identifier,
            signMessage: () => new Uint8Array(),
        };
        const client = new Client(await createClient(host, isSecure, undefined, inboxId, identifier), signer, []);
        return client.canMessage(identifiers);
    }
    codecFor(contentType) {
        return this.#codecs.get(contentType.toString());
    }
    encodeContent(content, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        const encoded = codec.encode(content, this);
        const fallback = codec.fallback(content);
        if (fallback) {
            encoded.fallback = fallback;
        }
        return encoded;
    }
    decodeContent(message, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        // throw an error if there's an invalid group membership change message
        if (contentType.sameAs(ContentTypeGroupUpdated) &&
            message.kind !== 1 /* GroupMessageKind.MembershipChange */) {
            throw new Error("Error decoding group membership change");
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return codec.decode(message.content, this);
    }
    async requestHistorySync() {
        return this.#innerClient.sendHistorySyncRequest();
    }
    async getInboxIdByIdentifier(identifier) {
        return this.#innerClient.findInboxIdByIdentifier(identifier);
    }
    signWithInstallationKey(signatureText) {
        return this.#innerClient.signWithInstallationKey(signatureText);
    }
    verifySignedWithInstallationKey(signatureText, signatureBytes) {
        try {
            this.#innerClient.verifySignedWithInstallationKey(signatureText, signatureBytes);
            return true;
        }
        catch {
            return false;
        }
    }
    static verifySignedWithPublicKey(signatureText, signatureBytes, publicKey) {
        try {
            verifySignedWithPublicKey(signatureText, signatureBytes, publicKey);
            return true;
        }
        catch {
            return false;
        }
    }
    static async isAddressAuthorized(inboxId, address, options) {
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        return await isAddressAuthorized(host, inboxId, address);
    }
    static async isInstallationAuthorized(inboxId, installation, options) {
        const host = options?.apiUrl || ApiUrls[options?.env || "dev"];
        return await isInstallationAuthorized(host, inboxId, installation);
    }
    static get version() {
        return version;
    }
}

const generateInboxId = (identifier) => {
    return generateInboxId$1(identifier);
};
const getInboxIdForIdentifier = async (identifier, env = "dev") => {
    const host = ApiUrls[env];
    const isSecure = host.startsWith("https");
    return getInboxIdForIdentifier$1(host, isSecure, identifier);
};

export { ApiUrls, Client, Conversation, Conversations, DecodedMessage, Dm, Group, HistorySyncUrls, generateInboxId, getInboxIdForIdentifier };
//# sourceMappingURL=index.js.map
