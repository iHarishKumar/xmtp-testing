import { ContentTypeId, ContentCodec, EncodedContent } from '@xmtp/content-type-primitives';
import * as _xmtp_node_bindings from '@xmtp/node-bindings';
import { Message, Conversation as Conversation$1, ListMessagesOptions, ConsentState, PermissionUpdateType, PermissionPolicy, MetadataField, Identifier, Conversations as Conversations$1, CreateGroupOptions, CreateDmOptions, ListConversationsOptions, Client as Client$1, Consent, ConsentEntityType, LogLevel, SignatureRequestType } from '@xmtp/node-bindings';
export { Consent, ConsentEntityType, ConsentState, ContentType, ContentTypeId, ConversationListItem, ConversationType, CreateDmOptions, CreateGroupOptions, DeliveryStatus, EncodedContent, GroupMember, GroupMembershipState, GroupMessageKind, GroupMetadata, GroupPermissions, GroupPermissionsOptions, HmacKey, Identifier, IdentifierKind, InboxState, Installation, ListConversationsOptions, ListMessagesOptions, LogLevel, LogOptions, Message, MessageDisappearingSettings, MetadataField, PermissionLevel, PermissionPolicy, PermissionPolicySet, PermissionUpdateType, SignatureRequestType, SortDirection } from '@xmtp/node-bindings';

type ResolveValue<T> = {
    value: T | undefined;
    done: boolean;
};
type StreamCallback<T> = (err: Error | null, value: T | undefined) => void;
declare class AsyncStream<T> {
    #private;
    onReturn: (() => void) | undefined;
    constructor();
    get isDone(): boolean;
    callback: StreamCallback<T>;
    next: () => Promise<ResolveValue<T>>;
    return: (value: T | undefined) => Promise<{
        done: boolean;
        value: T | undefined;
    }>;
    [Symbol.asyncIterator](): this;
}

type MessageKind = "application" | "membership_change";
type MessageDeliveryStatus = "unpublished" | "published" | "failed";
declare class DecodedMessage<T = any> {
    #private;
    content: T;
    contentType: ContentTypeId | undefined;
    conversationId: string;
    deliveryStatus: MessageDeliveryStatus;
    fallback?: string;
    compression?: number;
    id: string;
    kind: MessageKind;
    parameters: Record<string, string>;
    senderInboxId: string;
    sentAt: Date;
    sentAtNs: number;
    constructor(client: Client, message: Message);
}

declare class Conversation {
    #private;
    constructor(client: Client, conversation: Conversation$1, lastMessage?: Message | null);
    get id(): string;
    get isActive(): boolean;
    get addedByInboxId(): string;
    get createdAtNs(): number;
    get createdAt(): Date;
    metadata(): Promise<{
        creatorInboxId: string;
        conversationType: string;
    }>;
    members(): Promise<_xmtp_node_bindings.GroupMember[]>;
    sync(): Promise<void>;
    stream(callback?: StreamCallback<DecodedMessage>): AsyncStream<DecodedMessage<any>>;
    publishMessages(): Promise<void>;
    sendOptimistic(content: any, contentType?: ContentTypeId): string;
    send(content: any, contentType?: ContentTypeId): Promise<string>;
    messages(options?: ListMessagesOptions): Promise<DecodedMessage[]>;
    lastMessage(): Promise<DecodedMessage<any>>;
    get consentState(): ConsentState;
    updateConsentState(consentState: ConsentState): void;
    messageDisappearingSettings(): _xmtp_node_bindings.MessageDisappearingSettings | undefined;
    updateMessageDisappearingSettings(fromNs: number, inNs: number): Promise<void>;
    removeMessageDisappearingSettings(): Promise<void>;
    isMessageDisappearingEnabled(): boolean;
    pausedForVersion(): string | undefined;
}

declare class Dm extends Conversation {
    #private;
    constructor(client: Client, conversation: Conversation$1, lastMessage?: Message | null);
    get peerInboxId(): string;
}

declare class Group extends Conversation {
    #private;
    constructor(client: Client, conversation: Conversation$1, lastMessage?: Message | null);
    get name(): string;
    updateName(name: string): Promise<void>;
    get imageUrl(): string;
    updateImageUrl(imageUrl: string): Promise<void>;
    get description(): string;
    updateDescription(description: string): Promise<void>;
    get permissions(): {
        policyType: _xmtp_node_bindings.GroupPermissionsOptions;
        policySet: _xmtp_node_bindings.PermissionPolicySet;
    };
    updatePermission(permissionType: PermissionUpdateType, policy: PermissionPolicy, metadataField?: MetadataField): Promise<void>;
    get admins(): string[];
    get superAdmins(): string[];
    isAdmin(inboxId: string): boolean;
    isSuperAdmin(inboxId: string): boolean;
    addMembersByIdentifiers(identifiers: Identifier[]): Promise<void>;
    addMembers(inboxIds: string[]): Promise<void>;
    removeMembersByIdentifiers(identifiers: Identifier[]): Promise<void>;
    removeMembers(inboxIds: string[]): Promise<void>;
    addAdmin(inboxId: string): Promise<void>;
    removeAdmin(inboxId: string): Promise<void>;
    addSuperAdmin(inboxId: string): Promise<void>;
    removeSuperAdmin(inboxId: string): Promise<void>;
}

declare class Conversations {
    #private;
    constructor(client: Client, conversations: Conversations$1);
    getConversationById(id: string): Promise<Dm | Group | undefined>;
    getDmByInboxId(inboxId: string): Dm | undefined;
    getMessageById<T = any>(id: string): DecodedMessage<T> | undefined;
    newGroupWithIdentifiers(identifiers: Identifier[], options?: CreateGroupOptions): Promise<Group>;
    newGroup(inboxIds: string[], options?: CreateGroupOptions): Promise<Group>;
    newDmWithIdentifier(identifier: Identifier, options?: CreateDmOptions): Promise<Dm>;
    newDm(inboxId: string, options?: CreateDmOptions): Promise<Dm>;
    list(options?: ListConversationsOptions): Promise<(Dm | Group)[]>;
    listGroups(options?: Omit<ListConversationsOptions, "conversationType">): Group[];
    listDms(options?: Omit<ListConversationsOptions, "conversationType">): Dm[];
    sync(): Promise<void>;
    syncAll(consentStates?: ConsentState[]): Promise<bigint>;
    stream(callback?: StreamCallback<Group | Dm>): AsyncStream<Dm | Group>;
    streamGroups(callback?: StreamCallback<Group>): AsyncStream<Group>;
    streamDms(callback?: StreamCallback<Dm>): AsyncStream<Dm>;
    streamAllMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllGroupMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    streamAllDmMessages(callback?: StreamCallback<DecodedMessage>): Promise<AsyncStream<DecodedMessage<any>>>;
    hmacKeys(): Record<string, _xmtp_node_bindings.HmacKey[]>;
}

type SignMessage = (message: string) => Promise<Uint8Array> | Uint8Array;
type GetIdentifier = () => Promise<Identifier> | Identifier;
type GetChainId = () => bigint;
type GetBlockNumber = () => bigint;
type Signer = {
    type: "EOA";
    signMessage: SignMessage;
    getIdentifier: GetIdentifier;
} | {
    type: "SCW";
    signMessage: SignMessage;
    getIdentifier: GetIdentifier;
    getBlockNumber?: GetBlockNumber;
    getChainId: GetChainId;
};

type PreferenceUpdate = {
    type: string;
    HmacKeyUpdate?: {
        key: Uint8Array;
    };
};
declare class Preferences {
    #private;
    constructor(client: Client$1, conversations: Conversations$1);
    inboxState(refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.InboxState>;
    getLatestInboxState(inboxId: string): Promise<_xmtp_node_bindings.InboxState>;
    inboxStateFromInboxIds(inboxIds: string[], refreshFromNetwork?: boolean): Promise<_xmtp_node_bindings.InboxState[]>;
    setConsentStates(consentStates: Consent[]): Promise<void>;
    getConsentState(entityType: ConsentEntityType, entity: string): Promise<_xmtp_node_bindings.ConsentState>;
    streamConsent(callback?: StreamCallback<Consent[]>): AsyncStream<Consent[]>;
    streamPreferences(callback?: StreamCallback<PreferenceUpdate>): AsyncStream<PreferenceUpdate>;
}

declare const ApiUrls: {
    readonly local: "http://localhost:5556";
    readonly dev: "https://grpc.dev.xmtp.network:443";
    readonly production: "https://grpc.production.xmtp.network:443";
};
declare const HistorySyncUrls: {
    readonly local: "http://localhost:5558";
    readonly dev: "https://message-history.dev.ephemera.network";
    readonly production: "https://message-history.production.ephemera.network";
};
type XmtpEnv = keyof typeof ApiUrls;
/**
 * Network options
 */
type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env?: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl?: string;
    /**
     * historySyncUrl can be used to override the `env` flag and connect to a
     * specific endpoint for syncing history
     */
    historySyncUrl?: string;
};
/**
 * Storage options
 */
type StorageOptions = {
    /**
     * Path to the local DB
     */
    dbPath?: string;
};
type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs?: ContentCodec[];
};
type OtherOptions = {
    /**
     * Enable structured JSON logging
     */
    structuredLogging?: boolean;
    /**
     * Logging level
     */
    loggingLevel?: LogLevel;
    /**
     * Disable automatic registration when creating a client
     */
    disableAutoRegister?: boolean;
};
type ClientOptions = NetworkOptions & StorageOptions & ContentOptions & OtherOptions;
declare class Client {
    #private;
    constructor(client: Client$1, signer: Signer, codecs: ContentCodec[]);
    static create(signer: Signer, encryptionKey: Uint8Array, options?: ClientOptions): Promise<Client>;
    get identifier(): Identifier;
    get inboxId(): string;
    get installationId(): string;
    get installationIdBytes(): Uint8Array<ArrayBufferLike>;
    get isRegistered(): boolean;
    get conversations(): Conversations;
    get preferences(): Preferences;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register` function instead.
     */
    unsafe_createInboxSignatureText(): Promise<string | null | undefined>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `unsafe_addAccount` function instead.
     *
     * The `allowInboxReassign` parameter must be true or this function will
     * throw an error.
     */
    unsafe_addAccountSignatureText(newAccountIdentifier: Identifier, allowInboxReassign?: boolean): Promise<string | undefined>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `removeAccount` function instead.
     */
    unsafe_removeAccountSignatureText(identifier: Identifier): Promise<string | undefined>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `revokeAllOtherInstallations` function
     * instead.
     */
    unsafe_revokeAllOtherInstallationsSignatureText(): Promise<string | undefined>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `revokeInstallations` function instead.
     */
    unsafe_revokeInstallationsSignatureText(installationIds: Uint8Array[]): Promise<string | undefined>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register`, `addAccount`,
     * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`
     * functions instead.
     */
    unsafe_addSignature(signatureType: SignatureRequestType, signatureText: string, signer: Signer): Promise<void>;
    /**
     * WARNING: This function should be used with caution. It is only provided
     * for use in special cases where the provided workflows do not meet the
     * requirements of an application.
     *
     * It is highly recommended to use the `register`, `addAccount`,
     * `removeAccount`, `revokeAllOtherInstallations`, or `revokeInstallations`
     * functions instead.
     */
    unsafe_applySignatures(): Promise<void>;
    register(): Promise<void>;
    /**
     * WARNING: This function should be used with caution. Adding a wallet already
     * associated with an inboxId will cause the wallet to lose access to
     * that inbox.
     *
     * The `allowInboxReassign` parameter must be true to reassign an inbox
     * already associated with a different account.
     */
    unsafe_addAccount(newAccountSigner: Signer, allowInboxReassign?: boolean): Promise<void>;
    removeAccount(identifier: Identifier): Promise<void>;
    revokeAllOtherInstallations(): Promise<void>;
    revokeInstallations(installationIds: Uint8Array[]): Promise<void>;
    canMessage(identifiers: Identifier[]): Promise<Map<string, boolean>>;
    static canMessage(identifiers: Identifier[], env?: XmtpEnv): Promise<Map<string, boolean>>;
    codecFor(contentType: ContentTypeId): ContentCodec | undefined;
    encodeContent(content: any, contentType: ContentTypeId): EncodedContent<Record<string, string>>;
    decodeContent(message: Message, contentType: ContentTypeId): any;
    requestHistorySync(): Promise<void>;
    getInboxIdByIdentifier(identifier: Identifier): Promise<string | null>;
    signWithInstallationKey(signatureText: string): Uint8Array<ArrayBufferLike>;
    verifySignedWithInstallationKey(signatureText: string, signatureBytes: Uint8Array): boolean;
    static verifySignedWithPublicKey(signatureText: string, signatureBytes: Uint8Array, publicKey: Uint8Array): boolean;
    static isAddressAuthorized(inboxId: string, address: string, options?: NetworkOptions): Promise<boolean>;
    static isInstallationAuthorized(inboxId: string, installation: Uint8Array, options?: NetworkOptions): Promise<boolean>;
    static get version(): string;
}

declare const generateInboxId: (identifier: Identifier) => string;
declare const getInboxIdForIdentifier: (identifier: Identifier, env?: XmtpEnv) => Promise<string | null>;

export { ApiUrls, Client, type ClientOptions, Conversation, Conversations, DecodedMessage, Dm, Group, HistorySyncUrls, type NetworkOptions, type OtherOptions, type PreferenceUpdate, type Signer, type StorageOptions, type StreamCallback, type XmtpEnv, generateInboxId, getInboxIdForIdentifier };
